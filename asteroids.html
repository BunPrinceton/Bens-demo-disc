<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tropical Asteroids - Fruit Blast</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #FFE4B5 100%);
            overflow: hidden;
            position: relative;
        }

        #beach-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .game-wrapper {
            position: relative;
            z-index: 10;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            max-height: 98vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .sun {
            position: absolute;
            top: 50px;
            right: 100px;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #FFD700, #FFA500);
            border-radius: 50%;
            box-shadow: 0 0 50px #FFD700;
            animation: pulse 3s ease-in-out infinite;
            z-index: 5;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        h1 {
            color: #FFD700;
            font-size: 1.4em;
            text-shadow: 0 0 10px #FF6B35, 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin: 2px 0 5px 0;
            text-align: center;
            line-height: 1.2;
        }

        .game-info {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-weight: bold;
            line-height: 1.1;
        }

        .stat {
            color: white;
            text-shadow: 0 0 5px #00ffff;
        }

        .stat span {
            color: #FFD700;
        }

        #game-canvas {
            border: 3px solid #FF6B35;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.5), 0 0 60px rgba(255, 215, 0, 0.3);
            background: #0a0e27;
            display: block;
            margin: 0 auto;
            transform-origin: center center;
        }

        @media (max-width: 920px) {
            #game-canvas {
                transform: scale(0.85);
            }
        }

        @media (max-height: 750px) {
            #game-canvas {
                transform: scale(0.8);
            }
        }

        @media (max-width: 920px) and (max-height: 750px) {
            #game-canvas {
                transform: scale(0.7);
            }
        }

        .controls {
            margin-top: 3px;
            color: white;
            text-align: center;
            font-size: 0.75em;
            text-shadow: 0 0 5px #00ffff;
            line-height: 1.2;
        }

        .controls div {
            margin: 1px 0;
        }

        #game-over-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 107, 53, 0.95);
            padding: 30px 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 5px solid #FFD700;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        #game-over-screen h2 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #FFD700;
        }

        #game-over-screen .message {
            color: white;
            font-size: 1.2em;
            margin: 10px 0;
        }

        #game-over-screen button {
            background: white;
            color: #FF6B35;
            border: none;
            padding: 12px 35px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 15px;
            transition: all 0.2s;
        }

        #game-over-screen button:hover {
            background: #FFD700;
            transform: scale(1.1);
        }

        .lives {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .life-icon {
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <canvas id="beach-background"></canvas>
    <div class="sun"></div>

    <div class="game-wrapper">
        <h1>ðŸŒ´ Tropical Asteroids ðŸŒ´</h1>

        <div class="game-info">
            <div class="stat">Score: <span id="score">0</span></div>
            <div class="stat">Level: <span id="level">1</span></div>
            <div class="stat">High: <span id="high-score">0</span></div>
            <div class="stat lives">
                Lives: <span id="lives-display"></span>
            </div>
        </div>

        <canvas id="game-canvas" width="900" height="600"></canvas>

        <div class="controls">
            <div>ðŸŽ® <strong>W</strong> Thrust â€¢ <strong>A/D</strong> Rotate â€¢ <strong>SPACE</strong> Shoot</div>
            <div>Blast the tropical fruits & veggies! Bigger ones break into smaller pieces!</div>
        </div>
    </div>

    <div id="game-over-screen">
        <h2 id="game-over-title">Game Over!</h2>
        <div class="message">Final Score: <span id="final-score">0</span></div>
        <div class="message">Level Reached: <span id="final-level">1</span></div>
        <div class="message">High Score: <span id="final-high-score">0</span></div>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <script>
        // Beach background setup
        const bgCanvas = document.getElementById('beach-background');
        const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;

        let waves = [];
        for (let i = 0; i < 5; i++) {
            waves.push({
                y: bgCanvas.height - 200 + i * 15,
                amplitude: 10 + i * 3,
                frequency: 0.01 - i * 0.001,
                speed: 0.5 + i * 0.2,
                offset: Math.random() * 100
            });
        }

        function drawBeach(time) {
            const gradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#FFE4B5');
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            waves.forEach((wave, index) => {
                bgCtx.beginPath();
                bgCtx.moveTo(0, bgCanvas.height);
                for (let x = 0; x <= bgCanvas.width; x++) {
                    const y = wave.y + Math.sin(x * wave.frequency + wave.offset + time * wave.speed * 0.001) * wave.amplitude;
                    bgCtx.lineTo(x, y);
                }
                bgCtx.lineTo(bgCanvas.width, bgCanvas.height);
                bgCtx.closePath();
                const alpha = 0.3 - index * 0.05;
                bgCtx.fillStyle = `rgba(64, 224, 208, ${alpha})`;
                bgCtx.fill();
            });

            bgCtx.fillStyle = '#F4A460';
            bgCtx.fillRect(0, bgCanvas.height - 150, bgCanvas.width, 150);

            drawPalmTree(100, bgCanvas.height - 200);
            drawPalmTree(bgCanvas.width - 150, bgCanvas.height - 180);
        }

        function drawPalmTree(x, y) {
            bgCtx.fillStyle = '#8B4513';
            bgCtx.fillRect(x - 10, y, 20, 100);
            bgCtx.fillStyle = '#228B22';
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60) * Math.PI / 180;
                bgCtx.beginPath();
                bgCtx.ellipse(x + Math.cos(angle) * 40, y + Math.sin(angle) * 40, 50, 15, angle, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }

        function animateBeach(time = 0) {
            drawBeach(time);
            requestAnimationFrame(animateBeach);
        }
        animateBeach();

        // Game canvas setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let score = 0;
        let level = 1;
        let lives = 3;
        let highScore = localStorage.getItem('tropicalAsteroidsHighScore') || 0;
        let gameOver = false;
        let keys = {};

        document.getElementById('high-score').textContent = highScore;

        // Fruits and vegetables for asteroids
        const FRUITS = [
            { emoji: 'ðŸ‰', name: 'Watermelon', color: '#FF6B6B' },
            { emoji: 'ðŸ', name: 'Pineapple', color: '#FFD700' },
            { emoji: 'ðŸ¥¥', name: 'Coconut', color: '#8B4513' },
            { emoji: 'ðŸŠ', name: 'Orange', color: '#FFA500' },
            { emoji: 'ðŸ‹', name: 'Lemon', color: '#FFFF00' },
            { emoji: 'ðŸ¥', name: 'Kiwi', color: '#98D8C8' },
            { emoji: 'ðŸ‡', name: 'Grape', color: '#9B59B6' },
            { emoji: 'ðŸ“', name: 'Strawberry', color: '#FF6B6B' },
            { emoji: 'ðŸ¥•', name: 'Carrot', color: '#FFA500' },
            { emoji: 'ðŸŒ½', name: 'Corn', color: '#FFD700' },
            { emoji: 'ðŸ¥’', name: 'Cucumber', color: '#98D8C8' },
            { emoji: 'ðŸ¥‘', name: 'Avocado', color: '#6BCF7F' },
            { emoji: 'ðŸ…', name: 'Tomato', color: '#FF6347' },
            { emoji: 'ðŸ¥¦', name: 'Broccoli', color: '#2C5F2D' },
            { emoji: 'ðŸ«‘', name: 'Pepper', color: '#FF6B35' },
            { emoji: 'ðŸ¥¬', name: 'Lettuce', color: '#98D8C8' }
        ];

        // Power-up types
        const POWERUP_TYPES = [
            { type: 'shield', emoji: 'ðŸ›¡ï¸', name: 'Shield', color: '#00CED1', duration: 5000, rarity: 'common' },
            { type: 'rapidfire', emoji: 'âš¡', name: 'Rapid Fire', color: '#FFD700', duration: 8000, rarity: 'common' },
            { type: 'multishot', emoji: 'âœ¨', name: 'Triple Shot', color: '#FF69B4', duration: 10000, rarity: 'common' },
            { type: 'nuke', emoji: 'ðŸ’¥', name: 'Screen Clear', color: '#FF6B35', duration: 0, rarity: 'common' },
            { type: 'slow', emoji: 'ðŸ•', name: 'Slow Time', color: '#9B59B6', duration: 7000, rarity: 'common' },
            { type: 'laserblast', emoji: 'ðŸ”«', name: 'Laser Blast', color: '#FF0000', duration: 8000, rarity: 'secret' },
            { type: 'slowmoshots', emoji: 'ðŸŽ¯', name: 'Precision Shots', color: '#00FF00', duration: 10000, rarity: 'secret' }
        ];

        // Ship
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            vx: 0,
            vy: 0,
            angle: -Math.PI / 2,
            size: 15,
            thrust: false,
            invulnerable: 0,
            rapidFire: 0,
            multiShot: 0,
            shield: 0,
            laserBlast: 0,
            slowMoShots: 0,
            lastShot: 0
        };

        // Arrays
        let asteroids = [];
        let bullets = [];
        let particles = [];
        let stars = [];
        let powerups = [];
        let activePowerups = [];
        let slowMotion = 0;

        // Create starfield
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                twinkle: Math.random() * Math.PI * 2
            });
        }

        // Keyboard controls
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ') {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        // Ship functions
        function updateShip() {
            // Rotation - very slow baseline
            if (keys['a']) ship.angle -= 0.03;
            if (keys['d']) ship.angle += 0.03;

            // Thrust - very slow baseline
            if (keys['w']) {
                ship.vx += Math.cos(ship.angle) * 0.08;
                ship.vy += Math.sin(ship.angle) * 0.08;
                ship.thrust = true;
            } else {
                ship.thrust = false;
            }

            // Shooting
            if (keys[' ']) {
                shoot();
            }

            // Friction
            ship.vx *= 0.99;
            ship.vy *= 0.99;

            // Update position
            ship.x += ship.vx;
            ship.y += ship.vy;

            // Wrap around screen
            if (ship.x < 0) ship.x = canvas.width;
            if (ship.x > canvas.width) ship.x = 0;
            if (ship.y < 0) ship.y = canvas.height;
            if (ship.y > canvas.height) ship.y = 0;

            // Decrease invulnerability
            if (ship.invulnerable > 0) ship.invulnerable--;
        }

        function drawShip() {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);

            // Draw surfboard ship
            if (ship.invulnerable % 10 < 5 || ship.invulnerable === 0) {
                // Board
                ctx.fillStyle = '#00CED1';
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-15, -10);
                ctx.lineTo(-15, 10);
                ctx.closePath();
                ctx.fill();

                // Stripe
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(10, -5);
                ctx.lineTo(-10, -5);
                ctx.moveTo(10, 5);
                ctx.lineTo(-10, 5);
                ctx.stroke();

                // Thrust flame
                if (ship.thrust) {
                    ctx.fillStyle = '#FF6B35';
                    ctx.beginPath();
                    ctx.moveTo(-15, 0);
                    ctx.lineTo(-25, -5);
                    ctx.lineTo(-20, 0);
                    ctx.lineTo(-25, 5);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            ctx.restore();
        }

        function shoot() {
            if (gameOver) return;

            const now = Date.now();
            const cooldown = ship.rapidFire > 0 ? 100 : 200;
            if (now - ship.lastShot < cooldown) return;
            ship.lastShot = now;

            // Determine bullet speed based on power-up
            let bulletSpeed = 2.5; // Default: 150 pixels/second
            if (ship.laserBlast > 0) {
                bulletSpeed = 50; // Super fast laser
            } else if (ship.slowMoShots > 0) {
                bulletSpeed = 0.42; // Slow-mo precision shots
            }

            // Normal shot
            bullets.push({
                x: ship.x + Math.cos(ship.angle) * 20,
                y: ship.y + Math.sin(ship.angle) * 20,
                vx: Math.cos(ship.angle) * bulletSpeed,
                vy: Math.sin(ship.angle) * bulletSpeed,
                life: 360
            });

            // Multi-shot - add two more bullets at angles
            if (ship.multiShot > 0) {
                const spread = 0.3;
                bullets.push({
                    x: ship.x + Math.cos(ship.angle + spread) * 20,
                    y: ship.y + Math.sin(ship.angle + spread) * 20,
                    vx: Math.cos(ship.angle + spread) * bulletSpeed,
                    vy: Math.sin(ship.angle + spread) * bulletSpeed,
                    life: 360
                });
                bullets.push({
                    x: ship.x + Math.cos(ship.angle - spread) * 20,
                    y: ship.y + Math.sin(ship.angle - spread) * 20,
                    vx: Math.cos(ship.angle - spread) * bulletSpeed,
                    vy: Math.sin(ship.angle - spread) * bulletSpeed,
                    life: 360
                });
            }
        }

        // Bullet functions
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;

                // Wrap around
                if (bullet.x < 0) bullet.x = canvas.width;
                if (bullet.x > canvas.width) bullet.x = 0;
                if (bullet.y < 0) bullet.y = canvas.height;
                if (bullet.y > canvas.height) bullet.y = 0;

                return bullet.life > 0;
            });
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#FFD700';
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        // Asteroid functions
        function createAsteroid(x, y, size, vx, vy) {
            const fruit = FRUITS[Math.floor(Math.random() * FRUITS.length)];
            asteroids.push({
                x: x !== undefined ? x : Math.random() * canvas.width,
                y: y !== undefined ? y : Math.random() * canvas.height,
                vx: vx !== undefined ? vx : (Math.random() - 0.5) * 1.2,
                vy: vy !== undefined ? vy : (Math.random() - 0.5) * 1.2,
                size: size || 3,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                fruit: fruit
            });
        }

        function updateAsteroids() {
            const speedMult = slowMotion > 0 ? 0.5 : 1;
            asteroids.forEach(asteroid => {
                asteroid.x += asteroid.vx * speedMult;
                asteroid.y += asteroid.vy * speedMult;
                asteroid.rotation += asteroid.rotationSpeed * speedMult;

                // Wrap around
                if (asteroid.x < -50) asteroid.x = canvas.width + 50;
                if (asteroid.x > canvas.width + 50) asteroid.x = -50;
                if (asteroid.y < -50) asteroid.y = canvas.height + 50;
                if (asteroid.y > canvas.height + 50) asteroid.y = -50;
            });
        }

        function drawAsteroids() {
            asteroids.forEach(asteroid => {
                const radius = asteroid.size * 15;

                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.rotation);

                // Glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = asteroid.fruit.color;

                // Draw fruit emoji
                ctx.font = `${radius * 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(asteroid.fruit.emoji, 0, 0);

                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        // Particle effects
        function createParticles(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 30,
                    color: color,
                    size: Math.random() * 3 + 2
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // Power-up functions
        function spawnPowerup(x, y) {
            // 5% chance for secret power-up, 95% for common ones
            let type;
            if (Math.random() < 0.05) {
                // Random secret power-up
                const secretPowerups = POWERUP_TYPES.filter(p => p.rarity === 'secret');
                type = secretPowerups[Math.floor(Math.random() * secretPowerups.length)];
            } else {
                // Common power-ups only
                const commonPowerups = POWERUP_TYPES.filter(p => p.rarity === 'common');
                type = commonPowerups[Math.floor(Math.random() * commonPowerups.length)];
            }
            powerups.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                type: type.type,
                emoji: type.emoji,
                color: type.color,
                name: type.name,
                duration: type.duration,
                life: 300 // Disappears after 5 seconds
            });
        }

        function updatePowerups() {
            const speedMult = slowMotion > 0 ? 0.5 : 1;
            powerups = powerups.filter(p => {
                p.x += p.vx * speedMult;
                p.y += p.vy * speedMult;
                p.life--;

                // Wrap around
                if (p.x < 0) p.x = canvas.width;
                if (p.x > canvas.width) p.x = 0;
                if (p.y < 0) p.y = canvas.height;
                if (p.y > canvas.height) p.y = 0;

                // Check collision with ship
                const dx = p.x - ship.x;
                const dy = p.y - ship.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 25) {
                    collectPowerup(p);
                    return false;
                }

                return p.life > 0;
            });
        }

        function drawPowerups() {
            powerups.forEach(p => {
                ctx.save();
                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = p.color;

                // Draw emoji
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.emoji, p.x, p.y);

                // Draw pulsing circle
                const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                ctx.globalAlpha = 0.3 * pulse;
                ctx.strokeStyle = p.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 20 * pulse, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            });
        }

        function collectPowerup(powerup) {
            createParticles(powerup.x, powerup.y, powerup.color, 20);

            switch(powerup.type) {
                case 'shield':
                    ship.shield = Date.now() + powerup.duration;
                    activePowerups.push({ name: powerup.name, endTime: ship.shield });
                    break;
                case 'rapidfire':
                    ship.rapidFire = Date.now() + powerup.duration;
                    activePowerups.push({ name: powerup.name, endTime: ship.rapidFire });
                    break;
                case 'multishot':
                    ship.multiShot = Date.now() + powerup.duration;
                    activePowerups.push({ name: powerup.name, endTime: ship.multiShot });
                    break;
                case 'nuke':
                    // Clear all asteroids
                    asteroids.forEach(a => {
                        createParticles(a.x, a.y, a.fruit.color);
                        score += a.size * 20;
                    });
                    asteroids = [];
                    updateScore();
                    break;
                case 'slow':
                    slowMotion = Date.now() + powerup.duration;
                    activePowerups.push({ name: powerup.name, endTime: slowMotion });
                    break;
                case 'laserblast':
                    ship.laserBlast = Date.now() + powerup.duration;
                    activePowerups.push({ name: powerup.name, endTime: ship.laserBlast });
                    break;
                case 'slowmoshots':
                    ship.slowMoShots = Date.now() + powerup.duration;
                    activePowerups.push({ name: powerup.name, endTime: ship.slowMoShots });
                    break;
            }

            updateActivePowerups();
        }

        function updateActivePowerups() {
            const now = Date.now();

            // Update ship power-up timers
            if (ship.shield > 0 && now > ship.shield) ship.shield = 0;
            if (ship.rapidFire > 0 && now > ship.rapidFire) ship.rapidFire = 0;
            if (ship.multiShot > 0 && now > ship.multiShot) ship.multiShot = 0;
            if (ship.laserBlast > 0 && now > ship.laserBlast) ship.laserBlast = 0;
            if (ship.slowMoShots > 0 && now > ship.slowMoShots) ship.slowMoShots = 0;
            if (slowMotion > 0 && now > slowMotion) slowMotion = 0;

            // Filter expired power-ups from active list
            activePowerups = activePowerups.filter(p => now < p.endTime);
        }

        function drawActivePowerups() {
            if (activePowerups.length === 0) return;

            ctx.save();
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';

            activePowerups.forEach((p, i) => {
                const timeLeft = Math.ceil((p.endTime - Date.now()) / 1000);
                ctx.fillStyle = '#FFD700';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                const text = `${p.name}: ${timeLeft}s`;
                ctx.strokeText(text, 10, 30 + i * 25);
                ctx.fillText(text, 10, 30 + i * 25);
            });

            ctx.restore();
        }

        function drawShipShield() {
            if (ship.shield > 0) {
                ctx.save();
                const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
                ctx.globalAlpha = 0.4 * pulse;
                ctx.strokeStyle = '#00CED1';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(ship.x, ship.y, 30 * pulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // Collision detection
        function checkCollisions() {
            // Bullet-asteroid collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const bullet = bullets[i];
                    const asteroid = asteroids[j];
                    const dx = bullet.x - asteroid.x;
                    const dy = bullet.y - asteroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < asteroid.size * 15) {
                        // Hit!
                        createParticles(asteroid.x, asteroid.y, asteroid.fruit.color);

                        // Score
                        score += asteroid.size * 10;
                        updateScore();

                        // Break into smaller asteroids
                        if (asteroid.size > 1) {
                            for (let k = 0; k < 2; k++) {
                                createAsteroid(
                                    asteroid.x,
                                    asteroid.y,
                                    asteroid.size - 1,
                                    asteroid.vx * 0.9 + (Math.random() - 0.5) * 0.8,
                                    asteroid.vy * 0.9 + (Math.random() - 0.5) * 0.8
                                );
                            }
                        } else {
                            // Chance to spawn power-up when small asteroid is destroyed
                            if (Math.random() < 0.15) {
                                spawnPowerup(asteroid.x, asteroid.y);
                            }
                        }

                        asteroids.splice(j, 1);
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }

            // Ship-asteroid collisions
            if (ship.invulnerable === 0 && ship.shield === 0) {
                for (let i = asteroids.length - 1; i >= 0; i--) {
                    const asteroid = asteroids[i];
                    const dx = ship.x - asteroid.x;
                    const dy = ship.y - asteroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < ship.size + asteroid.size * 15) {
                        // Hit ship!
                        createParticles(ship.x, ship.y, '#00CED1', 25);
                        lives--;
                        updateLives();

                        if (lives <= 0) {
                            endGame();
                        } else {
                            // Reset ship
                            ship.x = canvas.width / 2;
                            ship.y = canvas.height / 2;
                            ship.vx = 0;
                            ship.vy = 0;
                            ship.invulnerable = 120;
                        }
                        break;
                    }
                }
            }

            // Check for level complete
            if (asteroids.length === 0 && !gameOver) {
                nextLevel();
            }
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('tropicalAsteroidsHighScore', highScore);
                document.getElementById('high-score').textContent = highScore;
            }
        }

        function updateLives() {
            const livesDisplay = document.getElementById('lives-display');
            livesDisplay.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const icon = document.createElement('span');
                icon.className = 'life-icon';
                icon.textContent = 'ðŸ„';
                livesDisplay.appendChild(icon);
            }
        }

        function nextLevel() {
            level++;
            document.getElementById('level').textContent = level;

            // Spawn more asteroids
            const count = 3 + level;
            for (let i = 0; i < count; i++) {
                // Spawn away from ship
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (Math.abs(x - ship.x) < 150 && Math.abs(y - ship.y) < 150);

                createAsteroid(x, y, 3);
            }

            // Bonus points
            score += level * 100;
            updateScore();
        }

        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('final-level').textContent = level;
            document.getElementById('final-high-score').textContent = highScore;
            document.getElementById('game-over-screen').style.display = 'block';
        }

        function restartGame() {
            gameOver = false;
            score = 0;
            level = 1;
            lives = 3;

            ship.x = canvas.width / 2;
            ship.y = canvas.height / 2;
            ship.vx = 0;
            ship.vy = 0;
            ship.angle = -Math.PI / 2;
            ship.invulnerable = 120;
            ship.rapidFire = 0;
            ship.multiShot = 0;
            ship.shield = 0;
            ship.laserBlast = 0;
            ship.slowMoShots = 0;
            ship.lastShot = 0;

            asteroids = [];
            bullets = [];
            particles = [];
            powerups = [];
            activePowerups = [];
            slowMotion = 0;

            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            updateLives();
            document.getElementById('game-over-screen').style.display = 'none';

            // Start with some asteroids
            for (let i = 0; i < 4; i++) {
                createAsteroid();
            }
        }

        // Draw starfield
        function drawStars() {
            stars.forEach(star => {
                star.twinkle += 0.05;
                const brightness = (Math.sin(star.twinkle) + 1) / 2;
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            drawStars();

            if (!gameOver) {
                updateShip();
                updateBullets();
                updateAsteroids();
                updateParticles();
                updatePowerups();
                updateActivePowerups();
                checkCollisions();
            }

            drawShipShield();
            drawShip();
            drawBullets();
            drawAsteroids();
            drawParticles();
            drawPowerups();
            drawActivePowerups();

            requestAnimationFrame(gameLoop);
        }

        // Start game
        updateLives();
        for (let i = 0; i < 4; i++) {
            createAsteroid();
        }
        gameLoop();
    </script>
</body>
</html>