<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tropical Minesweeper - Coconut Hunt</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #FFE4B5 100%);
            overflow: hidden;
        }

        #beach-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .game-wrapper {
            position: relative;
            z-index: 10;
        }

        .sun {
            position: absolute;
            top: 50px;
            right: 100px;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #FFD700, #FFA500);
            border-radius: 50%;
            box-shadow: 0 0 50px #FFD700;
            animation: pulse 3s ease-in-out infinite;
            z-index: 5;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        h1 {
            color: #FF6B35;
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
            margin-bottom: 10px;
        }

        .high-score-display {
            font-size: 1.2em;
            font-weight: bold;
            color: #FF6B35;
            margin-bottom: 15px;
        }

        .controls-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #FFE4B5, #FFDAB9);
            border-radius: 10px;
            border: 3px solid #FF6B35;
            gap: 20px;
        }

        .stats {
            display: flex;
            gap: 25px;
            font-size: 1.2em;
            font-weight: bold;
            color: #2C5F2D;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
        }

        button {
            background: #FF6B35;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #FF8555;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        button.active {
            background: #2C5F2D;
        }

        #game-board {
            display: inline-grid;
            gap: 2px;
            padding: 10px;
            background: #FF6B35;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, #F4A460, #DEB887);
            border: 2px solid #8B4513;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            transition: all 0.1s;
            user-select: none;
        }

        .cell:hover:not(.revealed):not(.flagged) {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        .cell.revealed {
            background: linear-gradient(145deg, #FFE4B5, #FFDAB9);
            border-color: #D2691E;
            cursor: default;
        }

        .cell.mine {
            background: linear-gradient(145deg, #FF6B6B, #FF4444);
        }

        .cell.flagged {
            background: linear-gradient(145deg, #FFD700, #FFA500);
        }

        .cell-emoji {
            font-size: 1.8em;
        }

        #game-over-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 107, 53, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 5px solid #FFD700;
        }

        #game-over-screen h2 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        #game-over-screen .message {
            color: white;
            font-size: 1.3em;
            margin: 15px 0;
        }

        #game-over-screen button {
            background: white;
            color: #FF6B35;
            padding: 15px 40px;
            font-size: 1.2em;
            margin: 10px;
        }

        .game-over-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .instructions {
            margin-top: 15px;
            color: #2C5F2D;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <canvas id="beach-background"></canvas>
    <div class="sun"></div>

    <div class="game-wrapper">
        <div class="game-container">
            <h1>üå¥ Tropical Minesweeper üå¥</h1>
            <div class="high-score-display">
                üèÜ Best Time: <span id="high-score">--</span>
            </div>

            <div class="controls-bar">
                <div class="stats">
                    <div>ü•• <span id="mines-left">10</span></div>
                    <div>‚è±Ô∏è <span id="timer">0:00</span></div>
                </div>
                <div class="difficulty-selector">
                    <button onclick="setDifficulty('easy')" class="active" id="easy-btn">Easy</button>
                    <button onclick="setDifficulty('medium')" id="medium-btn">Medium</button>
                    <button onclick="setDifficulty('hard')" id="hard-btn">Hard</button>
                </div>
                <button onclick="newGame()">üéÆ New Game</button>
            </div>

            <div id="game-board"></div>

            <div class="instructions">
                <strong>Left click</strong> to reveal ‚Ä¢ <strong>Right click</strong> to flag üèñÔ∏è
            </div>
        </div>
    </div>

    <div id="game-over-screen">
        <h2 id="game-over-title">You Win!</h2>
        <div class="message" id="game-over-message"></div>
        <div class="message">
            Time: <span id="final-time">0:00</span>
        </div>
        <div class="message">
            Best Time: <span id="final-high-score">--</span>
        </div>
        <div class="game-over-buttons">
            <button onclick="hideGameOver()">üëÅÔ∏è View Board</button>
            <button onclick="newGame()">üéÆ Play Again</button>
        </div>
    </div>

    <script>
        // Beach background
        const bgCanvas = document.getElementById('beach-background');
        const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;

        let waves = [];
        for (let i = 0; i < 5; i++) {
            waves.push({
                y: bgCanvas.height - 200 + i * 15,
                amplitude: 10 + i * 3,
                frequency: 0.01 - i * 0.001,
                speed: 0.5 + i * 0.2,
                offset: Math.random() * 100
            });
        }

        function drawBeach(time) {
            const gradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.7, '#FFE4B5');
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            waves.forEach((wave, index) => {
                bgCtx.beginPath();
                bgCtx.moveTo(0, bgCanvas.height);
                for (let x = 0; x <= bgCanvas.width; x++) {
                    const y = wave.y + Math.sin(x * wave.frequency + wave.offset + time * wave.speed * 0.001) * wave.amplitude;
                    bgCtx.lineTo(x, y);
                }
                bgCtx.lineTo(bgCanvas.width, bgCanvas.height);
                bgCtx.closePath();
                const alpha = 0.3 - index * 0.05;
                bgCtx.fillStyle = `rgba(64, 224, 208, ${alpha})`;
                bgCtx.fill();
            });

            bgCtx.fillStyle = '#F4A460';
            bgCtx.fillRect(0, bgCanvas.height - 150, bgCanvas.width, 150);

            drawPalmTree(100, bgCanvas.height - 200);
            drawPalmTree(bgCanvas.width - 150, bgCanvas.height - 180);
        }

        function drawPalmTree(x, y) {
            bgCtx.fillStyle = '#8B4513';
            bgCtx.fillRect(x - 10, y, 20, 100);
            bgCtx.fillStyle = '#228B22';
            for (let i = 0; i < 6; i++) {
                const angle = (i * 60) * Math.PI / 180;
                bgCtx.beginPath();
                bgCtx.ellipse(x + Math.cos(angle) * 40, y + Math.sin(angle) * 40, 50, 15, angle, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }

        function animateBeach(time = 0) {
            drawBeach(time);
            requestAnimationFrame(animateBeach);
        }
        animateBeach();

        // Game state
        const difficulties = {
            easy: { rows: 8, cols: 10, mines: 10 },
            medium: { rows: 14, cols: 18, mines: 40 },
            hard: { rows: 20, cols: 24, mines: 99 }
        };

        let currentDifficulty = 'easy';
        let board = [];
        let revealed = 0;
        let flagged = 0;
        let gameOver = false;
        let gameWon = false;
        let firstClick = true;
        let startTime = null;
        let timerInterval = null;
        let highScores = {
            easy: localStorage.getItem('tropicalMinesweeperEasy') || null,
            medium: localStorage.getItem('tropicalMinesweeperMedium') || null,
            hard: localStorage.getItem('tropicalMinesweeperHard') || null
        };

        updateHighScoreDisplay();

        function setDifficulty(diff) {
            currentDifficulty = diff;
            document.querySelectorAll('.difficulty-selector button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${diff}-btn`).classList.add('active');
            updateHighScoreDisplay();
            newGame();
        }

        function updateHighScoreDisplay() {
            const score = highScores[currentDifficulty];
            document.getElementById('high-score').textContent = score ? formatTime(parseInt(score)) : '--';
        }

        function newGame() {
            const config = difficulties[currentDifficulty];
            gameOver = false;
            gameWon = false;
            firstClick = true;
            revealed = 0;
            flagged = 0;
            startTime = null;
            clearInterval(timerInterval);
            document.getElementById('timer').textContent = '0:00';
            document.getElementById('game-over-screen').style.display = 'none';

            // Create board
            board = [];
            for (let r = 0; r < config.rows; r++) {
                board[r] = [];
                for (let c = 0; c < config.cols; c++) {
                    board[r][c] = {
                        mine: false,
                        revealed: false,
                        flagged: false,
                        adjacentMines: 0
                    };
                }
            }

            updateMinesDisplay();
            renderBoard();
        }

        function placeMines(excludeRow, excludeCol) {
            const config = difficulties[currentDifficulty];
            let minesPlaced = 0;

            while (minesPlaced < config.mines) {
                const r = Math.floor(Math.random() * config.rows);
                const c = Math.floor(Math.random() * config.cols);

                // Don't place mine on first click or adjacent cells
                const isFirstClick = r === excludeRow && c === excludeCol;
                const isAdjacent = Math.abs(r - excludeRow) <= 1 && Math.abs(c - excludeCol) <= 1;

                if (!board[r][c].mine && !isFirstClick && !isAdjacent) {
                    board[r][c].mine = true;
                    minesPlaced++;
                }
            }

            // Calculate adjacent mines
            for (let r = 0; r < config.rows; r++) {
                for (let c = 0; c < config.cols; c++) {
                    if (!board[r][c].mine) {
                        board[r][c].adjacentMines = countAdjacentMines(r, c);
                    }
                }
            }
        }

        function countAdjacentMines(row, col) {
            let count = 0;
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const r = row + dr;
                    const c = col + dc;
                    if (r >= 0 && r < board.length && c >= 0 && c < board[0].length) {
                        if (board[r][c].mine) count++;
                    }
                }
            }
            return count;
        }

        function renderBoard() {
            const config = difficulties[currentDifficulty];
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${config.cols}, 40px)`;

            for (let r = 0; r < config.rows; r++) {
                for (let c = 0; c < config.cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    cell.addEventListener('click', () => handleCellClick(r, c));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(r, c);
                    });

                    gameBoard.appendChild(cell);
                }
            }
        }

        function handleCellClick(row, col) {
            if (gameOver || gameWon) return;
            if (board[row][col].flagged || board[row][col].revealed) return;

            if (firstClick) {
                placeMines(row, col);
                firstClick = false;
                startTimer();
            }

            if (board[row][col].mine) {
                revealMines();
                endGame(false);
                return;
            }

            revealCell(row, col);

            const config = difficulties[currentDifficulty];
            const totalCells = config.rows * config.cols;
            if (revealed === totalCells - config.mines) {
                endGame(true);
            }
        }

        function handleRightClick(row, col) {
            if (gameOver || gameWon) return;
            if (board[row][col].revealed) return;

            board[row][col].flagged = !board[row][col].flagged;
            flagged += board[row][col].flagged ? 1 : -1;
            updateMinesDisplay();
            updateCell(row, col);
        }

        function revealCell(row, col) {
            if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return;
            if (board[row][col].revealed || board[row][col].flagged) return;

            board[row][col].revealed = true;
            revealed++;
            updateCell(row, col);

            // Auto-reveal adjacent cells if no adjacent mines
            if (board[row][col].adjacentMines === 0) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        revealCell(row + dr, col + dc);
                    }
                }
            }
        }

        // Map numbers to fruit/veggie emojis based on color
        const numberEmojis = {
            1: 'ü´ê',  // Blueberry (blue)
            2: 'ü•ù',  // Kiwi (green)
            3: 'üçì',  // Strawberry (red)
            4: 'üçá',  // Grape (purple)
            5: 'üçí',  // Cherry (dark red)
            6: 'üçã',  // Lemon (cyan-ish yellow)
            7: 'üçÜ',  // Eggplant (dark/black)
            8: 'ü•î'   // Potato (gray/brown)
        };

        function updateCell(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const cellData = board[row][col];

            cell.className = 'cell';

            if (cellData.revealed) {
                cell.classList.add('revealed');
                if (cellData.mine) {
                    cell.classList.add('mine');
                    cell.innerHTML = '<span class="cell-emoji">ü••</span>';
                } else if (cellData.adjacentMines > 0) {
                    cell.innerHTML = `<span class="cell-emoji">${numberEmojis[cellData.adjacentMines]}</span>`;
                }
            } else if (cellData.flagged) {
                cell.classList.add('flagged');
                cell.innerHTML = '<span class="cell-emoji">üèñÔ∏è</span>';
            } else {
                cell.textContent = '';
            }
        }

        function revealMines() {
            for (let r = 0; r < board.length; r++) {
                for (let c = 0; c < board[0].length; c++) {
                    if (board[r][c].mine) {
                        board[r][c].revealed = true;
                        updateCell(r, c);
                    }
                }
            }
        }

        function updateMinesDisplay() {
            const config = difficulties[currentDifficulty];
            document.getElementById('mines-left').textContent = config.mines - flagged;
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('timer').textContent = formatTime(elapsed);
            }, 1000);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function endGame(won) {
            gameOver = true;
            gameWon = won;
            clearInterval(timerInterval);

            const finalTime = Math.floor((Date.now() - startTime) / 1000);
            const gameOverScreen = document.getElementById('game-over-screen');
            const title = document.getElementById('game-over-title');
            const message = document.getElementById('game-over-message');

            if (won) {
                title.textContent = 'üéâ You Win! üéâ';
                message.textContent = 'All coconuts found!';

                // Check high score
                const currentHigh = highScores[currentDifficulty];
                if (!currentHigh || finalTime < parseInt(currentHigh)) {
                    highScores[currentDifficulty] = finalTime;
                    localStorage.setItem(`tropicalMinesweeper${currentDifficulty.charAt(0).toUpperCase() + currentDifficulty.slice(1)}`, finalTime);
                    message.textContent = 'üèÜ New Best Time! üèÜ';
                }
            } else {
                title.textContent = 'üí• Game Over! üí•';
                message.textContent = 'You hit a coconut!';
            }

            document.getElementById('final-time').textContent = formatTime(finalTime);
            document.getElementById('final-high-score').textContent =
                highScores[currentDifficulty] ? formatTime(parseInt(highScores[currentDifficulty])) : '--';
            updateHighScoreDisplay();
            gameOverScreen.style.display = 'block';
        }

        function hideGameOver() {
            document.getElementById('game-over-screen').style.display = 'none';
        }

        // Start game
        newGame();
    </script>
</body>
</html>